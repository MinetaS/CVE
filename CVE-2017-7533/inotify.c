#include "conf.h"

extern volatile int stop;


static void inotify_handle_events(int fd) {
    char buf[0x1000] __attribute__((aligned(__alignof__(struct inotify_event))));
    const struct inotify_event *event;

    while (1) {
        ssize_t r = read(fd, buf, 0x1000);

        if (r == -1 && errno != EAGAIN) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        if (r <= 0) {
            break;
        }

        for (char *ptr=buf ; ptr<buf+r ; ptr+=sizeof(struct inotify_event)+event->len) {
            event = (const struct inotify_event *)ptr;

            if (event->len && strcmp(event->name, FILE_SHORT_NAME)) {
                //printf("  * event->name = %s, event->len = %u\n", event->name, event->len);

                if (!strcmp(event->name, FILE_LONG_NAME)) {
                    printf("[+] Detected overwrite.\n");
                    stop = 1;
                    break;
                }
            }
        }
    }
}

void *t_inotify_event(void *_args __attribute__((unused))) {
    setvbuf(stdout, NULL, _IONBF, 0);

    int fd = inotify_init1(IN_NONBLOCK);

    if (fd == -1) {
        perror("inotify_init");
        exit(EXIT_FAILURE);
    }

    int wd = inotify_add_watch(fd, DIR_TEST, IN_OPEN | IN_CLOSE | IN_ACCESS);

    if (wd == -1) {
        perror("inotify_add_watch");
        exit(EXIT_FAILURE);
    }

    struct pollfd fds[1];

    fds[0].fd = fd;
    fds[0].events = POLLIN;

    puts("  - Listening for events...");

    while (!stop) {
        int p = poll(fds, 1, 250);

        if (p == -1 && errno != EINTR) {
            perror("poll");
            exit(EXIT_FAILURE);
        }

        if (p > 0) {
            if (fds[0].revents & POLLIN) {
                inotify_handle_events(fd);
                continue;
            }
        }
    
        break;
    }

    close(fd);
    pthread_exit(NULL);
}